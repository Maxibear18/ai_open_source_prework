<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini MMORPG Client</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Minimap UI -->
    <div id="minimap">
        <canvas id="minimapCanvas"></canvas>
        <div id="minimapTitle">Minimap</div>
    </div>
    
    
    <script>
        // Game state
        let gameState = {
            playerId: null,
            players: {},
            avatars: {},
            worldImage: null,
            viewportOffsetX: 0,
            viewportOffsetY: 0,
            myPosition: { x: 0, y: 0 },
            keysPressed: {},
            isMoving: false
        };
        
        // Get canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Get minimap canvas and context
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        
        // WebSocket connection
        let ws = null;
        
        // Set canvas size to fill the browser window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            updateViewport();
            renderMinimap();
        }
        
        // Load and draw the world map
        function loadWorldMap() {
            const worldImage = new Image();
            worldImage.onload = function() {
                gameState.worldImage = worldImage;
                render();
            };
            worldImage.src = 'world.jpg';
        }
        
        // Connect to game server
        function connectToServer() {
            ws = new WebSocket('wss://codepath-mmorg.onrender.com');
            
            ws.onopen = function() {
                console.log('Connected to game server');
                joinGame();
            };
            
            ws.onmessage = function(event) {
                const message = JSON.parse(event.data);
                handleServerMessage(message);
            };
            
            ws.onclose = function() {
                console.log('Disconnected from game server');
                // Attempt to reconnect after 3 seconds
                setTimeout(connectToServer, 3000);
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
            };
        }
        
        // Send join game message
        function joinGame() {
            const joinMessage = {
                action: 'join_game',
                username: 'Sirr'
            };
            ws.send(JSON.stringify(joinMessage));
        }
        
        // Handle server messages
        function handleServerMessage(message) {
            console.log('Server message:', message);
            
            switch(message.action) {
                case 'join_game':
                    if (message.success) {
                        gameState.playerId = message.playerId;
                        gameState.players = message.players;
                        gameState.avatars = message.avatars;
                        
                        // Find my position
                        if (gameState.players[gameState.playerId]) {
                            gameState.myPosition = {
                                x: gameState.players[gameState.playerId].x,
                                y: gameState.players[gameState.playerId].y
                            };
                            updateViewport();
                        }
                        
                        console.log('Joined game successfully!', gameState);
                    } else {
                        console.error('Failed to join game:', message.error);
                    }
                    break;
                    
                case 'player_joined':
                    gameState.players[message.player.id] = message.player;
                    gameState.avatars[message.avatar.name] = message.avatar;
                    break;
                    
                case 'players_moved':
                    Object.assign(gameState.players, message.players);
                    
                    // Update my position if it changed
                    if (gameState.playerId && message.players[gameState.playerId]) {
                        const newPosition = message.players[gameState.playerId];
                        gameState.myPosition = {
                            x: newPosition.x,
                            y: newPosition.y
                        };
                        updateViewport();
                    }
                    break;
                    
                case 'player_left':
                    delete gameState.players[message.playerId];
                    break;
                    
            }
            
            render();
            renderMinimap();
        }
        
        // Update viewport to center on player
        function updateViewport() {
            if (!gameState.myPosition) return;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Calculate offset to center player
            gameState.viewportOffsetX = centerX - gameState.myPosition.x;
            gameState.viewportOffsetY = centerY - gameState.myPosition.y;
            
            // Clamp to map boundaries
            const mapSize = 2048;
            gameState.viewportOffsetX = Math.max(gameState.viewportOffsetX, canvas.width - mapSize);
            gameState.viewportOffsetX = Math.min(gameState.viewportOffsetX, 0);
            gameState.viewportOffsetY = Math.max(gameState.viewportOffsetY, canvas.height - mapSize);
            gameState.viewportOffsetY = Math.min(gameState.viewportOffsetY, 0);
        }
        
        // Render the game
        function render() {
            if (!gameState.worldImage) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw world map
            ctx.drawImage(
                gameState.worldImage, 
                gameState.viewportOffsetX, 
                gameState.viewportOffsetY
            );
            
            // Draw all players
            Object.values(gameState.players).forEach(player => {
                drawPlayer(player);
            });
        }
        
        // Draw a single player
        function drawPlayer(player) {
            if (!gameState.avatars[player.avatar]) return;
            
            const avatar = gameState.avatars[player.avatar];
            const screenX = player.x + gameState.viewportOffsetX;
            const screenY = player.y + gameState.viewportOffsetY;
            
            // Check if player is visible on screen
            if (screenX < -50 || screenX > canvas.width + 50 || 
                screenY < -50 || screenY > canvas.height + 50) {
                return;
            }
            
            // Get the correct animation frame
            const direction = player.facing;
            const frameIndex = player.animationFrame || 0;
            
            if (avatar.frames[direction] && avatar.frames[direction][frameIndex]) {
                const imageData = avatar.frames[direction][frameIndex];
                
                // Create image from base64 data
                const img = new Image();
                img.onload = function() {
                    // Calculate avatar size (maintain aspect ratio)
                    const maxSize = 32;
                    const aspectRatio = img.width / img.height;
                    let width = maxSize;
                    let height = maxSize / aspectRatio;
                    
                    if (height > maxSize) {
                        height = maxSize;
                        width = maxSize * aspectRatio;
                    }
                    
                    // Draw avatar
                    const x = screenX - width / 2;
                    const y = screenY - height;
                    
                    // Handle west direction (flip east frames)
                    if (direction === 'west') {
                        ctx.save();
                        ctx.scale(-1, 1);
                        ctx.drawImage(img, -x - width, y, width, height);
                        ctx.restore();
                    } else {
                        ctx.drawImage(img, x, y, width, height);
                    }
                    
                    // Draw username label
                    drawUsernameLabel(player.username, screenX, screenY - height - 5);
                };
                img.src = imageData;
            }
        }
        
        // Draw username label
        function drawUsernameLabel(username, x, y) {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(x - username.length * 3, y - 15, username.length * 6, 12);
            
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(username, x, y - 3);
            ctx.restore();
        }
        
        // Keyboard movement handling
        function handleKeyDown(event) {
            if (event.repeat) return; // Prevent repeated keydown events
            
            const key = event.key;
            let direction = null;
            
            switch(key) {
                case 'ArrowUp':
                    direction = 'up';
                    break;
                case 'ArrowDown':
                    direction = 'down';
                    break;
                case 'ArrowLeft':
                    direction = 'left';
                    break;
                case 'ArrowRight':
                    direction = 'right';
                    break;
            }
            
            if (direction && !gameState.keysPressed[key]) {
                gameState.keysPressed[key] = true;
                sendMoveCommand(direction);
            }
        }
        
        function handleKeyUp(event) {
            const key = event.key;
            
            if (gameState.keysPressed[key]) {
                delete gameState.keysPressed[key];
                
                // If no keys are pressed, stop moving
                if (Object.keys(gameState.keysPressed).length === 0) {
                    sendStopCommand();
                }
            }
        }
        
        function sendMoveCommand(direction) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const moveMessage = {
                    action: 'move',
                    direction: direction
                };
                ws.send(JSON.stringify(moveMessage));
                console.log('Sent move command:', direction);
            }
        }
        
        function sendStopCommand() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const stopMessage = {
                    action: 'stop'
                };
                ws.send(JSON.stringify(stopMessage));
                console.log('Sent stop command');
            }
        }
        
        // Minimap rendering
        function renderMinimap() {
            if (!gameState.worldImage) return;
            
            const minimapSize = 200;
            const worldSize = 2048;
            const scale = minimapSize / worldSize;
            
            // Clear minimap
            minimapCtx.clearRect(0, 0, minimapSize, minimapSize);
            
            // Draw world map background (scaled down)
            minimapCtx.drawImage(gameState.worldImage, 0, 0, minimapSize, minimapSize);
            
            // Draw viewport indicator
            const viewportX = -gameState.viewportOffsetX * scale;
            const viewportY = -gameState.viewportOffsetY * scale;
            const viewportWidth = canvas.width * scale;
            const viewportHeight = canvas.height * scale;
            
            minimapCtx.strokeStyle = '#00ff00';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(viewportX, viewportY, viewportWidth, viewportHeight);
            
            // Draw player dots
            Object.values(gameState.players).forEach((player, index) => {
                const x = player.x * scale;
                const y = player.y * scale;
                const isMe = player.id === gameState.playerId;
                
                // Player dot
                minimapCtx.fillStyle = isMe ? '#ff0000' : getPlayerColor(index);
                minimapCtx.beginPath();
                minimapCtx.arc(x, y, isMe ? 4 : 3, 0, 2 * Math.PI);
                minimapCtx.fill();
                
                // Border for better visibility
                minimapCtx.strokeStyle = '#000000';
                minimapCtx.lineWidth = 1;
                minimapCtx.stroke();
            });
        }
        
        // Get player color for minimap and chat
        function getPlayerColor(index) {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'];
            return colors[index % colors.length];
        }
        
        
        // Initialize the game
        function init() {
            resizeCanvas();
            loadWorldMap();
            connectToServer();
        }
        
        // Handle window resize
        window.addEventListener('resize', resizeCanvas);
        
        // Handle keyboard events
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        
        // Start the game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
